<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nagar Rakshak - Multi-language Voice Agent</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
      color: #e0e0e0;
    }

    .container {
      background: rgba(255, 255, 255, 0.06);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 24px;
      padding: 30px 40px 40px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      max-width: 680px;
      width: 100%;
    }

    h1 {
      text-align: center;
      color: #fff;
      margin-bottom: 6px;
      font-size: 26px;
    }

    .subtitle {
      text-align: center;
      color: #8899aa;
      margin-bottom: 20px;
      font-size: 13px;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 20px;
      border-radius: 12px;
      background: rgba(0, 0, 0, 0.25);
      padding: 4px;
      justify-content: center;
    }

    .tab-btn {
      flex: 1;
      padding: 10px 16px;
      border: none;
      border-radius: 10px;
      background: transparent;
      color: #8899aa;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .tab-btn:hover {
      color: #c0c8d0;
      background: rgba(255, 255, 255, 0.05);
    }

    .tab-btn.active {
      background: rgba(255, 255, 255, 0.12);
      color: #fff;
    }

    .tab-btn.active.kok {
      border-bottom: 2px solid #f5a623;
    }

    .tab-btn.active.en {
      border-bottom: 2px solid #51cf66;
    }

    .tab-btn.active.hi {
      border-bottom: 2px solid #74c0fc;
    }

    /* Status bar */
    .status-bar {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 12px 16px;
      border-radius: 12px;
      margin-bottom: 20px;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.3s;
    }

    .status-bar .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
      flex-shrink: 0;
    }

    .status-bar.disconnected {
      background: rgba(220, 53, 69, 0.15);
      color: #ff6b6b;
    }

    .status-bar.disconnected .dot {
      background: #ff6b6b;
    }

    .status-bar.connected {
      background: rgba(40, 167, 69, 0.15);
      color: #51cf66;
    }

    .status-bar.connected .dot {
      background: #51cf66;
    }

    .status-bar.listening {
      background: rgba(40, 167, 69, 0.15);
      color: #51cf66;
    }

    .status-bar.listening .dot {
      background: #51cf66;
      animation: blink 2s infinite;
    }

    .status-bar.recording {
      background: rgba(255, 193, 7, 0.15);
      color: #ffd43b;
    }

    .status-bar.recording .dot {
      background: #ffd43b;
      animation: pulse-dot 0.8s infinite;
    }

    .status-bar.processing {
      background: rgba(0, 123, 255, 0.15);
      color: #74c0fc;
    }

    .status-bar.processing .dot {
      background: #74c0fc;
      animation: blink 0.5s infinite;
    }

    .status-bar.speaking {
      background: rgba(155, 89, 182, 0.15);
      color: #b197fc;
    }

    .status-bar.speaking .dot {
      background: #b197fc;
      animation: pulse-dot 0.6s infinite;
    }

    @keyframes blink {

      0%,
      100% {
        opacity: 1
      }

      50% {
        opacity: 0.3
      }
    }

    @keyframes pulse-dot {

      0%,
      100% {
        transform: scale(1)
      }

      50% {
        transform: scale(1.4)
      }
    }

    /* Lang indicator */
    .lang-indicator {
      text-align: center;
      font-size: 11px;
      color: #667;
      margin-bottom: 12px;
    }

    .lang-indicator span {
      padding: 3px 10px;
      border-radius: 6px;
      font-weight: 600;
      background: rgba(255, 255, 255, 0.06);
    }

    /* Mic button */
    .mic-area {
      text-align: center;
      margin: 20px 0;
    }

    .mic-btn {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      border: 3px solid rgba(255, 255, 255, 0.2);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      font-size: 42px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 20px rgba(102, 126, 234, 0.3);
      transition: all 0.3s;
      position: relative;
    }

    .mic-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 30px rgba(102, 126, 234, 0.5);
    }

    .mic-btn.active {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      border-color: rgba(245, 87, 108, 0.5);
      animation: pulse-ring 1.5s infinite;
    }

    .mic-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
    }

    @keyframes pulse-ring {
      0% {
        box-shadow: 0 0 0 0 rgba(245, 87, 108, 0.5);
      }

      70% {
        box-shadow: 0 0 0 20px rgba(245, 87, 108, 0);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(245, 87, 108, 0);
      }
    }

    .mic-label {
      font-size: 12px;
      color: #8899aa;
      margin-top: 8px;
    }

    /* Conversation */
    .convo {
      margin-top: 16px;
      max-height: 300px;
      overflow-y: auto;
      scroll-behavior: smooth;
      padding-right: 4px;
    }

    .convo::-webkit-scrollbar {
      width: 6px;
    }

    .convo::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 3px;
    }

    .msg {
      margin-bottom: 12px;
      padding: 10px 14px;
      border-radius: 16px;
      max-width: 85%;
      word-wrap: break-word;
      font-size: 14px;
      line-height: 1.5;
    }

    .msg.user {
      background: rgba(102, 126, 234, 0.25);
      color: #c5cff5;
      margin-left: auto;
      border-bottom-right-radius: 4px;
    }

    .msg.agent {
      background: rgba(255, 255, 255, 0.08);
      color: #e0e0e0;
      border-bottom-left-radius: 4px;
    }

    .msg-label {
      font-size: 10px;
      opacity: 0.5;
      margin-bottom: 3px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .footer {
      text-align: center;
      margin-top: 16px;
      font-size: 12px;
      color: #556;
    }

    .footer button {
      background: none;
      border: 1px solid rgba(255, 255, 255, 0.15);
      color: #889;
      padding: 6px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
    }

    .footer button:hover {
      background: rgba(255, 255, 255, 0.05);
      color: #aab;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Nagar Rakshak</h1>
    <p class="subtitle">Multi-language Voice Agent -- Real-time Conversational AI</p>

    <div class="tabs">
      <button class="tab-btn kok active" data-lang="kok" onclick="switchTab('kok')">Konkani</button>
      <button class="tab-btn en" data-lang="en" onclick="switchTab('en')">English</button>
      <button class="tab-btn hi" data-lang="hi" onclick="switchTab('hi')">Hindi</button>
    </div>

    <div id="status" class="status-bar disconnected">
      <span class="dot"></span>
      <span id="statusText">Connecting...</span>
    </div>

    <div class="lang-indicator">
      Active: <span id="langBadge">Konkani</span>
    </div>

    <div class="mic-area">
      <button id="micBtn" class="mic-btn" disabled>&#x1F3A4;</button>
      <div class="mic-label" id="micLabel">Connect first</div>
    </div>

    <div id="convo" class="convo"></div>

    <div class="footer">
      <button onclick="resetConvo()">Clear conversation</button>
    </div>
  </div>

  <script>
    // ========== Configuration ==========
    const KONKANI_WS_PORT = 8765;   // Konkani pipeline
    const ENGLISH_WS_PORT = 8767;   // English-only pipeline
    const HINDI_WS_PORT = 8768;   // Hindi-only pipeline

    const SAMPLE_RATE_IN = 16000;
    const SAMPLE_RATE_OUT = 44100;
    const CHUNK_MS = 20;
    const CHUNK_SAMPLES = SAMPLE_RATE_IN * CHUNK_MS / 1000;  // 320

    // ========== Per-tab state ==========
    const TABS = {
      kok: { label: 'Konkani', port: KONKANI_WS_PORT, ws: null, convo: [], isActive: false, reconnTimer: null },
      en: { label: 'English', port: ENGLISH_WS_PORT, ws: null, convo: [], isActive: false, reconnTimer: null },
      hi: { label: 'Hindi', port: HINDI_WS_PORT, ws: null, convo: [], isActive: false, reconnTimer: null },
    };

    let currentLang = 'en';
    let audioCtx = null;
    let micStream = null;
    let scriptNode = null;
    let isMicOn = false;
    let playQueue = [];
    let isPlaying = false;
    let nextPlayTime = 0;

    const statusEl = document.getElementById('status');
    const statusText = document.getElementById('statusText');
    const micBtn = document.getElementById('micBtn');
    const micLabel = document.getElementById('micLabel');
    const convoEl = document.getElementById('convo');
    const langBadge = document.getElementById('langBadge');

    // ========== Tab switching ==========
    function switchTab(lang) {
      // Stop mic if active
      if (isMicOn) stopMic();
      // Stop any playback
      playQueue = [];
      isPlaying = false;

      // Update UI tabs
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      document.querySelector(`.tab-btn[data-lang="${lang}"]`).classList.add('active');

      currentLang = lang;
      langBadge.textContent = TABS[lang].label;

      // Render saved conversation for this tab
      renderConvo();

      // Update status based on this tab's WS state
      const tab = TABS[lang];
      if (tab.ws && tab.ws.readyState === 1) {
        setStatus('connected', `Connected -- click mic to start (${tab.label})`);
        micBtn.disabled = false;
        micLabel.textContent = 'Click to start';
      } else {
        setStatus('disconnected', `Connecting to ${tab.label} pipeline...`);
        micBtn.disabled = true;
        micLabel.textContent = 'Connect first';
        connectTab(lang);
      }
    }

    // ========== WebSocket per tab ==========
    function connectTab(lang) {
      const tab = TABS[lang];
      if (tab.ws && (tab.ws.readyState === 0 || tab.ws.readyState === 1)) return;

      const wsUrl = `ws://${location.hostname}:${tab.port}`;
      tab.ws = new WebSocket(wsUrl);
      tab.ws.binaryType = 'arraybuffer';

      tab.ws.onopen = () => {
        // No need to send set_language for dedicated pipelines
        // Each pipeline (English/Hindi) is hard-coded to its language
        if (lang === currentLang) {
          setStatus('connected', `Connected -- click mic to start (${tab.label})`);
          micBtn.disabled = false;
          micLabel.textContent = 'Click to start';
        }
      };

      tab.ws.onmessage = (evt) => {
        if (lang !== currentLang) return; // ignore messages from inactive tabs
        if (evt.data instanceof ArrayBuffer) {
          enqueueTTSAudio(evt.data);
        } else {
          const msg = JSON.parse(evt.data);
          handleServerMsg(msg, lang);
        }
      };

      tab.ws.onclose = () => {
        if (lang === currentLang) {
          setStatus('disconnected', `Disconnected from ${tab.label} -- reconnecting...`);
          micBtn.disabled = true;
          if (isMicOn) stopMic();
        }
        clearTimeout(tab.reconnTimer);
        tab.reconnTimer = setTimeout(() => connectTab(lang), 3000);
      };

      tab.ws.onerror = () => { };
    }

    function handleServerMsg(msg, lang) {
      const tab = TABS[lang];
      switch (msg.type) {
        case 'ready':
        case 'language_set':
          setStatus('connected', `Ready -- click mic to start (${tab.label})`);
          break;
        case 'speech_start':
          setStatus('recording', 'Listening to you...');
          break;
        case 'processing':
          setStatus('processing', 'Processing...');
          break;
        case 'transcription':
          addMessage(msg.text, 'user', lang);
          break;
        case 'response_text':
          addMessage(msg.text, 'agent', lang);
          break;
        case 'tts_start':
          setStatus('speaking', 'Agent speaking...');
          break;
        case 'tts_done':
          waitForPlaybackDone().then(() => {
            if (isMicOn && lang === currentLang) setStatus('listening', 'Listening...');
          });
          break;
        case 'interrupted':
          playQueue = [];
          setStatus('recording', 'Listening to you...');
          break;
        case 'turn_done':
          break;
        case 'speech_too_short':
          if (isMicOn) setStatus('listening', 'Listening...');
          break;
        case 'stt_empty':
          if (isMicOn) setStatus('listening', 'Could not hear -- try again');
          break;
        case 'error':
          setStatus('connected', `Error: ${msg.message}`);
          break;
        case 'reset_ok':
          tab.convo = [];
          renderConvo();
          break;
      }
    }

    // ========== Mic capture ==========
    micBtn.addEventListener('click', () => {
      if (!isMicOn) startMic();
      else stopMic();
    });

    async function startMic() {
      const tab = TABS[currentLang];
      if (!tab.ws || tab.ws.readyState !== 1) return;

      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE_IN });
        micStream = await navigator.mediaDevices.getUserMedia({
          audio: { sampleRate: SAMPLE_RATE_IN, channelCount: 1, echoCancellation: true, noiseSuppression: true }
        });

        const source = audioCtx.createMediaStreamSource(micStream);
        scriptNode = audioCtx.createScriptProcessor(512, 1, 1);

        let pcmBuffer = new Float32Array(0);

        scriptNode.onaudioprocess = (e) => {
          if (!isMicOn) return;
          const ws = TABS[currentLang].ws;
          if (!ws || ws.readyState !== 1) return;

          const input = e.inputBuffer.getChannelData(0);
          const newBuf = new Float32Array(pcmBuffer.length + input.length);
          newBuf.set(pcmBuffer);
          newBuf.set(input, pcmBuffer.length);
          pcmBuffer = newBuf;

          while (pcmBuffer.length >= CHUNK_SAMPLES) {
            const chunk = pcmBuffer.slice(0, CHUNK_SAMPLES);
            pcmBuffer = pcmBuffer.slice(CHUNK_SAMPLES);
            const s16 = new Int16Array(chunk.length);
            for (let i = 0; i < chunk.length; i++) {
              s16[i] = Math.max(-32768, Math.min(32767, Math.round(chunk[i] * 32767)));
            }
            ws.send(s16.buffer);
          }
        };

        source.connect(scriptNode);
        scriptNode.connect(audioCtx.destination);

        isMicOn = true;
        micBtn.classList.add('active');
        micLabel.textContent = 'Click to stop';
        setStatus('listening', 'Listening...');

      } catch (err) {
        console.error('Mic error:', err);
        setStatus('disconnected', 'Mic permission denied');
      }
    }

    function stopMic() {
      isMicOn = false;
      micBtn.classList.remove('active');
      micLabel.textContent = 'Click to start';

      if (scriptNode) { scriptNode.disconnect(); scriptNode = null; }
      if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
      if (audioCtx) { audioCtx.close().catch(() => { }); audioCtx = null; }

      setStatus('connected', `Mic off -- click to start (${TABS[currentLang].label})`);
    }

    // ========== TTS Playback ==========
    function enqueueTTSAudio(arrayBuffer) {
      playQueue.push(arrayBuffer);
      if (!isPlaying) startPlayback();
    }

    function startPlayback() {
      if (playQueue.length === 0) { isPlaying = false; return; }
      isPlaying = true;

      const playCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE_OUT });
      nextPlayTime = playCtx.currentTime + 0.05;

      function scheduleNext() {
        while (playQueue.length > 0) {
          const buf = playQueue.shift();
          const s16 = new Int16Array(buf);
          const float32 = new Float32Array(s16.length);
          for (let i = 0; i < s16.length; i++) float32[i] = s16[i] / 32768.0;

          const audioBuffer = playCtx.createBuffer(1, float32.length, SAMPLE_RATE_OUT);
          audioBuffer.getChannelData(0).set(float32);

          const src = playCtx.createBufferSource();
          src.buffer = audioBuffer;
          src.connect(playCtx.destination);

          if (nextPlayTime < playCtx.currentTime) nextPlayTime = playCtx.currentTime;
          src.start(nextPlayTime);
          nextPlayTime += audioBuffer.duration;
        }

        setTimeout(() => {
          if (playQueue.length > 0) {
            scheduleNext();
          } else {
            setTimeout(() => {
              if (playQueue.length > 0) scheduleNext();
              else { isPlaying = false; playCtx.close().catch(() => { }); }
            }, 500);
          }
        }, 50);
      }

      scheduleNext();
    }

    function waitForPlaybackDone() {
      return new Promise(resolve => {
        const check = () => {
          if (!isPlaying && playQueue.length === 0) resolve();
          else setTimeout(check, 200);
        };
        check();
      });
    }

    // ========== UI helpers ==========
    function setStatus(cls, text) {
      statusEl.className = 'status-bar ' + cls;
      statusText.textContent = text;
    }

    function addMessage(text, sender, lang) {
      if (!text) return;
      const tab = TABS[lang];
      tab.convo.push({ text, sender });
      if (lang === currentLang) renderConvo();
    }

    function renderConvo() {
      const tab = TABS[currentLang];
      convoEl.innerHTML = '';
      for (const m of tab.convo) {
        const wrap = document.createElement('div');
        wrap.className = 'msg ' + m.sender;
        const label = document.createElement('div');
        label.className = 'msg-label';
        label.textContent = m.sender === 'user' ? 'You' : 'Agent';
        const body = document.createElement('div');
        body.textContent = m.text;
        wrap.appendChild(label);
        wrap.appendChild(body);
        convoEl.appendChild(wrap);
      }
      convoEl.scrollTop = convoEl.scrollHeight;
    }

    function resetConvo() {
      const tab = TABS[currentLang];
      if (tab.ws && tab.ws.readyState === 1) {
        tab.ws.send(JSON.stringify({ type: 'reset' }));
      }
      tab.convo = [];
      renderConvo();
    }

    // ========== Init: connect to Konkani pipeline on load ==========
    connectTab('kok');
  </script>
</body>

</html>